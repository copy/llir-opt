#!/usr/bin/env python3

import argparse
import os
import random
import subprocess
import sys
import multiprocessing

POOL=10
SPREAD=5
ITERATIONS=1000


def which(exe):
  """Finds an executable in the path."""

  for path in os.environ["PATH"].split(os.pathsep):
    path = os.path.join(path, exe)
    if os.path.isfile(path) and os.access(path, os.X_OK):
      return path

  print('{} not found'.format(exe))
  sys.exit(-1)


def run_test(source, seed, opt_exe, reduce_exe, code, stdout_match, stderr_match):
  """Runs a single test and inspects its output."""
  
  proc_reduce = subprocess.run(
    [reduce_exe, "-o", "-", "-", "-seed", str(seed)],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    input=source.encode('utf-8')
  )
  if proc_reduce.returncode != 0:
    print(proc_reduce.stderr)
    sys.exit(-1)
    return None

  reduced_source = proc_reduce.stdout
  proc_opt = subprocess.run(
    [opt_exe, "-o", "-", "-"],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    input=reduced_source
  )
  if proc_opt.returncode != code:
    return None

  if stdout_match and stdout_match not in proc_opt.stdout.decode('utf-8'):
    return None
  if stderr_match and stderr_match not in proc_opt.stderr.decode('utf-8'):
    return None

  return reduced_source.decode('utf-8')


def runner(args):
  """Helper to run a test."""

  source, (opt, red, code, stdout, stderr) = args
  seed = random.randint(0, 1000000000)
  return run_test(source, seed, opt, red, code, stdout, stderr)


def cost(s):
  """Cost function for individual programs."""
  return s.count('\n')



if __name__ == "__main__":
  # Find full paths to the relevant executables.
  opt_exe = which('llir-opt')
  reduce_exe = which('llir-reduce')

  # Parse arguments.
  parser = argparse.ArgumentParser(description='LLIR test case reducer')
  parser.add_argument('--code', type=int)
  parser.add_argument('--stdout', type=str)
  parser.add_argument('--stderr', type=str)
  parser.add_argument('source', nargs=1)
  args = parser.parse_args()

  # Load the input data.
  with open(args.source[0], 'r') as f:
    source = f.read()

  # Initialise the thread pool.
  mp = multiprocessing.Pool(multiprocessing.cpu_count() - 1)
  state = (opt_exe, reduce_exe, args.code, args.stdout, args.stderr)

  # Populate the initial pool.
  pool = []
  pool_args = [(source, state) for _ in range(POOL * POOL)]
  for r in mp.imap_unordered(runner, pool_args):
    if r:
      pool.append(r)
  pool.sort(key=cost)
  pool = pool[:POOL]
  
  for i in range(ITERATIONS):
    new_pool = []
    for source in pool:
      for _ in range(SPREAD):
        r = runner(source)
        if r:
          new_pool.append(r)
    if new_pool:
      new_pool.sort(key=cost)
      pool = new_pool[:POOL]

  print(pool[0])
