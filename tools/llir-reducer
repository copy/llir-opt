#!/usr/bin/env python3

import argparse
import os
import random
import subprocess
import sys
import multiprocessing
import tempfile
import signal

from tqdm import tqdm



def which(exe):
  """Finds an executable in the path."""

  for path in os.environ["PATH"].split(os.pathsep):
    path = os.path.join(path, exe)
    if os.path.isfile(path) and os.access(path, os.X_OK):
      return path

  print('{} not found'.format(exe))
  sys.exit(-1)


def report_reducer_error(stderr, source, seed):
  """Reports information to reproduce an error."""

  with tempfile.NamedTemporaryFile(mode='w+b', delete=False) as f:
    print(
      '\nError:\n----\n{}\n----\nSeed: {}\nSource written to: {}\n\n'.format(
        stderr.decode('utf-8'),
        seed,
        f.name
      )
    )
    f.write(source)


def run_test(source, seed, flags, opt_exe, reduce_exe, code, stdout_match, stderr_match):
  """Runs a single test and inspects its output."""

  proc_reduce = subprocess.run(
    [reduce_exe, "-o", "-", "-", "-seed", str(seed)],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    input=source
  )
  if proc_reduce.returncode != 0:
    report_reducer_error(proc_reduce.stderr, source, seed)
    return None

  reduced_source = proc_reduce.stdout
  proc_opt = subprocess.run(
    [opt_exe, "-o", "-", "-"] + flags,
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    input=reduced_source
  )

  if proc_opt.returncode != code:
    if proc_opt.returncode != 0:
      report_reducer_error(proc_opt.stderr, source, seed)
    return None

  if stdout_match and stdout_match not in proc_opt.stdout.decode('utf-8'):
    report_reducer_error(proc_opt.stderr, source, seed)
    return None
  if stderr_match and stderr_match not in proc_opt.stderr.decode('utf-8'):
    report_reducer_error(proc_opt.stderr, source, seed)
    return None

  return reduced_source


def runner(args):
  """Helper to run a test."""

  source, (flags, opt, red, code, stdout, stderr) = args
  seed = random.randint(0, 1000000000)
  return run_test(source, seed, flags, opt, red, code, stdout, stderr)


def cost(s):
  """Cost function for individual programs."""

  if s[:4].decode('utf-8') == 'LLIR':
    return len(s)
  else:
    return s.count('\n') + s.count(':')


def generation(i, mp, pool, args):
  """Create a new generation from a pool."""

  new_pool = []

  pool_args = [(source, state) for source in pool] * args.spread

  progress = tqdm(
      mp.imap_unordered(runner, pool_args),
      total=len(pool_args),
      leave=False,
      desc='#{} Best: {}'.format(i, cost(pool[0]))
  )

  for r in progress:
    if r:
      new_pool.append(r)

  return new_pool



if __name__ == "__main__":
  # Find full paths to the relevant executables.
  opt_exe = which('llir-opt')
  reduce_exe = which('llir-reduce')

  # Parse arguments.
  parser = argparse.ArgumentParser(description='LLIR test case reducer')
  parser.add_argument('--code', type=int)
  parser.add_argument('--stdout', type=str)
  parser.add_argument('--stderr', type=str)
  parser.add_argument('source', nargs=1)
  parser.add_argument('--output', type=str)
  parser.add_argument('--flag', type=str, nargs='+', default=[])
  parser.add_argument('--pool', type=int, default=20)
  parser.add_argument('--spread', type=int, default=5)
  parser.add_argument('--iter', type=int, default=10000)
  parser.add_argument('-j', type=int, default=(multiprocessing.cpu_count() - 1))
  args = parser.parse_args()

  # Load the input data.
  with open(args.source[0], 'rb') as f:
    source = f.read()

  # Initialise the thread pool.
  original_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)
  mp = multiprocessing.Pool(args.j)
  signal.signal(signal.SIGINT, original_sigint_handler)

  try:
    state = (args.flag, opt_exe, reduce_exe, args.code, args.stdout, args.stderr)

    # Populate the initial pool.
    pool = [source]

    # Iterate and reduce.
    for i in list(range(args.iter)):
      new_pool = generation(i + 1, mp, pool, args)
      pool = sorted(new_pool + pool, key=cost)[:args.pool]
      if args.output:
        with open(args.output, 'wb') as f:
          f.write(pool[0])

    # Print the result
    if not output:
      print(pool[0])

  except KeyboardInterrupt:
    mp.terminate()
  else:
    mp.close()

  mp.join()
