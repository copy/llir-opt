#!/usr/bin/env python3

import argparse
import os
import random
import subprocess
import sys
import multiprocessing

from tqdm import tqdm



def which(exe):
  """Finds an executable in the path."""

  for path in os.environ["PATH"].split(os.pathsep):
    path = os.path.join(path, exe)
    if os.path.isfile(path) and os.access(path, os.X_OK):
      return path

  print('{} not found'.format(exe))
  sys.exit(-1)


def run_test(source, seed, opt_exe, reduce_exe, code, stdout_match, stderr_match):
  """Runs a single test and inspects its output."""

  proc_reduce = subprocess.run(
    [reduce_exe, "-o", "-", "-", "-seed", str(seed)],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    input=source.encode('utf-8')
  )
  if proc_reduce.returncode != 0:
    print(proc_reduce.stderr)
    sys.exit(-1)
    return None

  reduced_source = proc_reduce.stdout
  proc_opt = subprocess.run(
    [opt_exe, "-o", "-", "-"],
    stdout=subprocess.PIPE,
    stderr=subprocess.PIPE,
    input=reduced_source
  )
  if proc_opt.returncode != code:
    return None

  if stdout_match and stdout_match not in proc_opt.stdout.decode('utf-8'):
    return None
  if stderr_match and stderr_match not in proc_opt.stderr.decode('utf-8'):
    return None

  return reduced_source.decode('utf-8')


def runner(args):
  """Helper to run a test."""

  source, (opt, red, code, stdout, stderr) = args
  seed = random.randint(0, 1000000000)
  return run_test(source, seed, opt, red, code, stdout, stderr)


def cost(s):
  """Cost function for individual programs."""
  return s.count('\n')



if __name__ == "__main__":
  # Find full paths to the relevant executables.
  opt_exe = which('llir-opt')
  reduce_exe = which('llir-reduce')

  # Parse arguments.
  parser = argparse.ArgumentParser(description='LLIR test case reducer')
  parser.add_argument('--code', type=int)
  parser.add_argument('--stdout', type=str)
  parser.add_argument('--stderr', type=str)
  parser.add_argument('source', nargs=1)
  parser.add_argument('--output', type=str)
  parser.add_argument('--pool', type=int, default=20)
  parser.add_argument('--spread', type=int, default=5)
  parser.add_argument('--iter', type=int, default=10000)
  args = parser.parse_args()

  # Load the input data.
  with open(args.source[0], 'r') as f:
    source = f.read()

  # Initialise the thread pool.
  mp = multiprocessing.Pool(multiprocessing.cpu_count() - 1)
  state = (opt_exe, reduce_exe, args.code, args.stdout, args.stderr)

  # Populate the initial pool.
  pool = [source for _ in range(args.pool)]
  for i in list(range(args.iter)):
    new_pool = []

    pool_args = [(source, state) for source in pool] * args.spread
    for r in tqdm(mp.imap_unordered(runner, pool_args), total=len(pool_args), leave=False):
      if r:
        new_pool.append(r)

    if new_pool:
      pool = sorted(new_pool, key=cost)[:args.pool]

    if args.output:
      with open(args.output, 'w') as f:
        f.write(pool[0])

  if not output:
    print(pool[0])
